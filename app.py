# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LGipb880wgXZnPeRwekq1NbUvmeuCHV2
"""



"""# Importing Libraries"""

# from google.colab import drive
# drive.mount('/content/drive')

# !pip install tensorflow-gpu==1.15.0
# !pip install keras==2.2.5
# !pip install h5py==2.10.0
!pip install flask-ngrok
!pip install mrcnn
!pip install imgaug
import tensorflow
import keras
print("tensorflow version:", tensorflow.__version__)
print("keras version:",keras.__version__)

import json
from IPython.display import Image, display, clear_output
import shutil
import os
import numpy as np
from collections import Counter
from keras.applications.vgg16 import VGG16
from keras.applications.imagenet_utils import preprocess_input,decode_predictions
from tensorflow.keras.preprocessing import image
from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img
from keras.utils.data_utils import get_file
from keras.models import Sequential, load_model,Model
import h5py
import skimage

import pickle as pk

"""# Detecting Car"""

model1 = VGG16(weights = 'imagenet')
with open('static/models/vgg16_cat_list.pk', 'rb') as f:
    categ_count = pk.load(f)
CLASS_INDEX = None
CLASS_INDEX_PATH = 'https://s3.amazonaws.com/deep-learning-models/image-models/imagenet_class_index.json'

def get_predictions(preds, top=5):
    global CLASS_INDEX
    if len(preds.shape) != 2 or preds.shape[1] != 1000:
        raise ValueError('`decode_predictions` expects a batch of predictions (i.e. a 2D array of shape (samples, 1000)). Found array with shape: ' + str(preds.shape))
    if CLASS_INDEX is None:
        fpath = get_file('imagenet_class_index.json',CLASS_INDEX_PATH,cache_subdir='models')
        CLASS_INDEX = json.load(open(fpath))
    results = []
    for pred in preds:
        top_indices = pred.argsort()[-top:][::-1]
        result = [tuple(CLASS_INDEX[str(i)]) + (pred[i],) for i in top_indices]
        result.sort(key=lambda x: x[2], reverse=True)
        results.append(result)
    return results

def prepare_image(img_path):
    img = load_img(img_path, target_size=(224, 224))
    x = img_to_array(img)
    x = np.expand_dims(x, axis=0)
    x = preprocess_input(x)
    return x

def is_a_car(image,categ_list):
      img= prepare_image(image)

      out = model1.predict(img)
      preds = get_predictions(out, top=5)
      print("Identifying...")
      for pred in preds[0]:
          if pred[0:2] in categ_list:
              print(pred[0:2])
              return True
      return False

# is_a_car('/content/drive/MyDrive/car-damage-detection-using-mrcnn/car-damage-detection-using-CNN.zip (Unzipped Files)/car-damage-detection-using-CNN/static/upload/0003.jpg',categ_count)

"""# Detect Damage in Car"""

model2 = load_model('static/models/ft_model.h5')

def is_damaged(image_path,model2):
    # urllib.request.urlretrieve(image_path, 'save.jpg')
    img = load_img(image_path, target_size=(256,256))
    x = img_to_array(img)
    x = x.reshape((1,) + x.shape)/255
    pred = model2.predict(x)
    #print("Car is Damaged")
    print(pred)
    if(pred[0][0]<=0.5):
      print("Car is Damaged")
      return True
    else:
      print("Car is not Damaged")
      return False

# is_damaged('/content/drive/MyDrive/car-damage-detection-using-mrcnn/car-damage-detection-using-CNN.zip (Unzipped Files)/car-damage-detection-using-CNN/static/upload/0003.jpg',model2)

"""# Detecting Damage in Car using mask-rcnn"""


import keras.engine as KE
KE.Layer

# Commented out IPython magic to ensure Python compatibility.
import mrcnn.model as modellib

import os
import sys
os.chdir('.')
#ROOT DIRECTORY:
# Root directory 
ROOT_DIR= os.path.abspath("")
sys.path.append(ROOT_DIR) 

from mrcnn.config import Config
from mrcnn import utils
#import mrcnn.model as modellib
from mrcnn import visualize

# %matplotlib inline

#directory to save logs and trained model
# To find local version of the library
MODEL_DIR = os.path.join(ROOT_DIR, "logs")

COCO_MODEL_PATH = os.path.join(ROOT_DIR,'mask_rcnn_coco.h5')
#DOWnload coco trained weights

if not os.path.exists(COCO_MODEL_PATH):
  utils.download_trained_weights(COCO_MODEL_PATH)

#Directory of images to run detection on
IMAGE_DIR= os.path.join(ROOT_DIR,'images')

# Commented out IPython magic to ensure Python compatibility.
import itertools
import math
import logging
import json
import re
import random
from collections import OrderedDict
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.lines as lines
from matplotlib.patches import Polygon

# Import Mask RCNN
#sys.path.append(ROOT_DIR)  # To find local version of the library

import keras.engine as KE
from mrcnn.visualize import display_images
from mrcnn.model import log
import cv2
import custom,custom_1
import imgaug,h5py,IPython

ROOT_DIR = os.getcwd()
sys.path.append(ROOT_DIR)  # To find local version of the library
MODEL_DIR = os.path.join(ROOT_DIR, "logs")
custom_WEIGHTS_PATH = "static/models/mask_rcnn_scratch_0003.h5"  # TODO: update this path for best performing iteration weights
config = custom.CustomConfig()
# custom_DIR = '/content/drive/MyDrive/car-damage-detection-using-CNN/custom/'
# custom_DIR

config = custom.CustomConfig()
class InferenceConfig(config.__class__):
    # Run detection on one image at a time
    GPU_COUNT = 1
    IMAGES_PER_GPU = 1

config = InferenceConfig()
config.display()

# Device to load the neural network on.
# Useful if you're training a model on the same 
# machine, in which case use CPU and leave the
# GPU for training.
DEVICE = "/cpu:0"  # /cpu:0 or /gpu:0

# Inspect the model in training or inference modes
# values: 'inference' or 'training'
# TODO: code for 'training' test mode not ready yet
TEST_MODE = "inference"

def get_ax(rows=1, cols=1, size=16):
    """Return a Matplotlib Axes array to be used in
    all visualizations in the notebook. Provide a
    central point to control graph sizes.
    
    Adjust the size attribute to control how big to render images
    """
    _, ax = plt.subplots(rows, cols, figsize=(size*cols, size*rows))
    return ax

from importlib import reload # was constantly changin the visualization, so I decided to reload it instead of notebook
reload(visualize)


# Create model in inference mode
# import tensorflow as tf
with tensorflow.device(DEVICE):
  model= modellib.MaskRCNN(mode='inference', model_dir= MODEL_DIR, config= config)

# custom_WEIGHTS_PATH = '/content/drive/MyDrive/car-damage-detection-using-mrcnn/car-damage-detection-using-CNN.zip (Unzipped Files)/car-damage-detection-using-CNN/static/models/mask_rcnn_scratch_0004.h5'
# Load weights
print("Loading weights ", custom_WEIGHTS_PATH)
model.load_weights(custom_WEIGHTS_PATH, by_name=True)    
model.keras_model._make_predict_function()

"""# Deploying model

"""

#deploy model using flask:


import zipfile
from skimage import data,io
from flask import render_template, request, Flask, url_for,flash, redirect
from flask_ngrok import run_with_ngrok

from werkzeug.utils import secure_filename
import warnings
app= Flask(__name__)
app= Flask(__name__,static_folder='/content/drive/MyDrive/car-damage-detection-using-mrcnn/car-damage-detection-using-CNN.zip (Unzipped Files)/car-damage-detection-using-CNN/static',template_folder='/content/drive/MyDrive/car-damage-detection-using-mrcnn/car-damage-detection-using-CNN.zip (Unzipped Files)/car-damage-detection-using-CNN/templates')
run_with_ngrok(app)

app.secret_key = "secret key"
UPLOAD_PATH= '/content/drive/MyDrive/car-damage-detection-using-mrcnn/car-damage-detection-using-CNN.zip (Unzipped Files)/car-damage-detection-using-CNN/static/upload'
app.config['UPLOAD_FOLDER'] = UPLOAD_PATH
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024
Allowed_extensions= ['jpg','jpeg','png']
zipped_extensions=['zip']

def allowed_file(filename):
	return '.' in filename and filename.rsplit('.', 1)[1].lower() in Allowed_extensions
def zipped_file(filename):
	return '.' in filename and filename.rsplit('.', 1)[1].lower() in zipped_extensions
@app.route('/')
def upload_form():
	return render_template('base.html')

def zip_file(filename):
  zipupload=True
  try:
    with zipfile.ZipFile(filename) as zf:
      zf.extractall(os.path.join(UPLOAD_PATH))
  except BadZipfile as e:
    print(e)
    return "", 406
  image_paths=[]
  for imgs in os.listdir(UPLOAD_PATH):
    if os.path.splitext(imgs)[1].lower() in ['.png', '.jpg', '.jpeg']:
      image_paths.append(os.path.join(UPLOAD_PATH, imgs))
  print(image_paths)
  image_len= len(image_paths)
  for image_path in image_paths:
    print(image_path)
    img = io.imread(image_path)  
    io.imshow(img)
    plt.show()
# If grayscale. Convert to RGB for consistency.
    if is_a_car(image_path, categ_count):
      print("Car Found...")
      print("Detecting Damage....")
      if is_damaged(image_path,model2):
        print("Damage Detected.....")
        print("Locating Damage....")
        if img.ndim != 3:
            img = skimage.color.gray2rgb(img)
        # If has an alpha channel, remove it for consistency
        if img.shape[-1] == 4:
            img = img[..., :3]
        #print(img.shape)
        img, window, scale, padding, crop = utils.resize_image(img,
                                                              min_dim=config.IMAGE_MIN_DIM,
                                                              min_scale=config.IMAGE_MIN_SCALE,
                                                              max_dim=config.IMAGE_MAX_DIM,
                                                              mode=config.IMAGE_RESIZE_MODE)
        print(img.shape)
        #Run Damage detection
        

        img_arr = np.array(img)
        results = model.detect([img], verbose=1)
        ax= get_ax(1)
        ax = plt.gca()
        r = results[0]
        visualize.display_instances(img_arr, r['rois'], r['masks'], r['class_ids'], 
                                    dataset.class_names, r['scores'],ax=ax, title='Predictions')
        loc= '/content/drive/MyDrive/car-damage-detection-using-mrcnn/car-damage-detection-using-CNN.zip (Unzipped Files)/car-damage-detection-using-CNN/static/prediction'+image_path.split('.')[0]
                    
        plt.savefig(loc ,bbox_inches='tight', pad_inches=-0.5,orientation= 'landscape') 
        
      else:
        print("NO Damage Detected!!!!!!")
        
    else:
      print("No Car Found!!!!!!")
      
@app.route('/', methods=['POST'])
def upload_image():
	fileupload=False
	zipupload=False
	if 'file' not in request.files:
		flash('No file part')
		return redirect(request.url)
	file = request.files['file']
	if file.filename == '':
		flash('No image selected for uploading')
		return redirect(request.url)
	print(file.filename)
	f= file.filename
	ext= f.split('.')[-1]
	if ext.lower() in Allowed_extensions:
		filename = secure_filename(file.filename)
		file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
		file_path= UPLOAD_PATH+'/'+filename
		fileupload=True
		print('upload_image filename: ' + filename)
		flash('Image successfully uploaded and displayed below')
		class_names=['BG','scratch']
    #is a car
		print("FILE PATH IS:",file_path)
		is_car= is_a_car(file_path,categ_count)
		if is_car:
			print("Car Found")
	 		
			damaged_car= is_damaged(file_path,model2)
			if damaged_car:
				print("CAR IS DAMAGED")
				print("PREDICTING DAMAGE......")
				image = io.imread(file_path)  
				io.imshow(image)
				plt.show()
				#rescaling image
				if image.ndim != 3:
					image = skimage.color.gray2rgb(image)
			# If has an alpha channel, remove it for consistency
				if image.shape[-1] == 4:
						image = image[..., :3]
				#print(img.shape)
				image, window, scale, padding, crop = utils.resize_image(image,
																															min_dim=config.IMAGE_MIN_DIM,
																															min_scale=config.IMAGE_MIN_SCALE,
																															max_dim=config.IMAGE_MAX_DIM,
																															mode=config.IMAGE_RESIZE_MODE)
				print(image.shape)
				
			
				  #Run Damage detection
				print("Running damage detection")
				img_arr = np.array(image)
				results = model.detect([image], verbose=1)
				ax= get_ax(1)
				ax = plt.gca()
				r = results[0]
				loc= '/content/drive/MyDrive/car-damage-detection-using-mrcnn/car-damage-detection-using-CNN.zip (Unzipped Files)/car-damage-detection-using-CNN/static/prediction'
				visualize.display_instances(img_arr, r['rois'], r['masks'], r['class_ids'],class_names, r['scores'],ax=ax, title='Predictions')
				plt.savefig(loc+'/'+filename,bbox_inches='tight', pad_inches=-0.5,orientation= 'landscape')
				# image2 = io.imread(loc+'/'+filename)  
				# io.imshow(image2)
				plt.show()
				
				return render_template('damage.html',fileupload= fileupload,is_car= is_car, damaged_car= damaged_car, filename=filename,imagename= filename)
		
			return render_template('damage.html',fileupload= fileupload,is_car= is_car, damaged_car= damaged_car) 
		return render_template('damage.html',fileupload= fileupload,is_car= is_car, damaged_car= damaged_car)
	elif ext.lower() in zipped_extensions:
		print("You have uploaded a zip file")
		zip_file(file.filename)
		return render_template('damage.html', image_len= image_len)
	else:
		flash('Allowed image types are -> png, jpg, jpeg, gif and zipped extensions')
		return redirect(request.url)
	
@app.route('/display/<filename>')
def display_image(filename):
	#print('display_image filename: ' + filename)
	return redirect(url_for('static', filename='upload/' + filename), code=301)
@app.route('/display<imagename>')
def predict_image(imagename):
	print('display_predicted filename: ' + imagename)
	return redirect(url_for('static', filename='prediction/' + imagename), code=301)
	# return redirect(url_for('static', filename='prediction/' + imagename), code=301)
# @app.route("/downloadfile/<filename>", methods = ['GET'])
# def download_image():
# 		return render_template('damage.html',value=filename)
@app.route('/download-zip')
def request_zip():
    base_path = pathlib.Path('./prediction/')
    data = io.BytesIO()
    with zipfile.ZipFile(data, mode='w') as z:
        for f_name in base_path.iterdir():
            z.write(f_name)
    data.seek(0)
    return fl.send_file(
        data,
        mimetype='application/zip',
        as_attachment=True,
        attachment_filename='damaged_cars.zip'
    )

if __name__=="__main__":                                           
    app.run()